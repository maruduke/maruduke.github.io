---
title: 4. 도커 볼륨을 이용한 퍼시스턴트 스토리지
author: maruduke
date: 2023-09-30 14:10:00 +0800
categories: [Docker]
tags: [docker]
---

## 컨테이너 속 데이터가 사라지는 이유

도커 컨테이너에도 단일 드라이브로 된 파일 시스템이 있다. 이 파일 시스템의 내용은 이미지 속 파일로부터 만들어지는데 Dockerfile의 COPY로 파일을 복사하면, 컨테이너에도 같은 경로에 복사된 파일이 있다.
  
모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만, 그중 한 컨테이너에서 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다.
  
컨테이너의 파일 시스템은 단일 디스크다. 그러나 이 디스크는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템이다. 이 출처는 기본적으로 이미지 레이어와 컨테이너의 기록 가능 레이어로 구성되는데, 이미지 레이어는 모든 컨테이너가 공유하지만 기록 가능 레이어는 컨테이너마다 다르다.

  
기록 가능 레이어는 새 파일을 만드는데만 사용하는 것이 아닌 이미지 레이어에 있는 파일도 수정할 수 있다. 도커는 **기록 중 복사** 방법을 사용해 읽기 전용 레이어의 파일을 수정할 수 있다. 컨테이너에서 이미지 레이어에 포함된 파일을 수정하려면, 먼저 도커가 이 파일을 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 파일을 수정한다.

컨테이너를 삭제하면 이 컨테이너의 기록 가능 레이어와 수정된 데이터도 함께 삭제된다. 도커를 사용하면 컨테이너 삭제를 반복하게된다. 실무에서는 새 이미지를 빌드하고 오래된 컨테이너를 삭제한 다음 실행한 컨테이너로 대체하는 방법으로 애플리케이션을 업데이트한다. 이 과정에서 기존 컨테이너에 있는 수정된 데이터는 모두 손실된다. 가령 컨테이너로 데이터베이스를 실행해 사용했는데 데이터베이스 버전을 업데이트 했더니 모든 데이터가 사라지는 문제가 발생할 수 있다.
  
도커는 이런 상황을 감안하여 **도커 볼륨**과 **마운트**로 컨테이너와 별개의 생애주기를 갖는 요소를 추가한다.


## 도커 볼륨을 사용하는 컨테이너 실행하기

도커 볼륨은 도커에서  스토리지를 다루는 단위이다. 볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다. 퍼시스턴시가 필요한 유상태 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉터리가 된다.

컨테이너에서 볼륨을 사용하는 방법은 두 가지다. 
- 수동으로 직접 볼륨을 생성해 컨테이너에 연결하는 방법
- Dockerfile에서 VOLUME인스트럭션을 사용하는 방법

볼륨이 사용된 멀티 스테이지 빌드 Dockerfile
``` dockerfile
FROM diamol/dotnet-aspnet
WORKDIR /app
ENTRYPOINT ["dotnet", "ToDoList.dll"]

VOLUME /data
COPY --from=builder /out/ .

```

이 이미지부터 컨테이너를 실행하면 자동으로 볼륨을 생성해 컨테이너에 연결해 준다. 실행된 컨테이너에는 /data디렉터리가 있는데 다른 디렉터리와 똑같이 사용할 수 있지만 이 디렉터리는 볼륨에 영구적으로 저장된다.
  
컨테이너와 연결된 볼륨을 살펴보자
``` Console
$ docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list

$ docker container inspect --format '{{.Mounts}}' todo1

$ docker volumn ls
```

도커 이미지에서 볼륨을 정의하면 컨테이너를 생성할 때마다 새로운 볼륨을 만든다. 하지만 컨테이너가 같은 볼륨을 공유하게 할 수 있다. 같은 데이터를 공유하는 컨테이너 2개를 만드는 방법은 다음과 같다.
``` console
# 컨테이널를 실행하면 볼륨 생성
$ docker container run --name todo2 -d diamol/ch06-todo-list

# 리눅스 환경일 경우
$ docker container exec todo2 ls /data

# 이 컨테이너는 todo1의 볼륨을 공유한다.
docker container run -d name t3 --volumns-from todo1 diamol/ch06-todo-list

# 리눅스 환경일 경우
$ docker container exec t3 ls /data

```

볼륨을 생성하고 버전 1의 to-do 애플리케이션에서 볼륨을 사용하라. 그 다음 애플리케이션을 버전2로 업데이트 해보자

``` Console
# 복사 대상 경로를 환경 변수로 정의
$target= './data' # 리눅스 컨테이너

# 데이터를 저장할 볼륨을 생성한다.
docker volumn create todo-list

# 볼륨을 연결해 v1 애플리케이션을 실행한다.
docker container run -d -p 8011:80 -v todo-list:$target --name todo-v1 diamol/ch06-todo-list

# 페이지에서 데이터를 추가함

# v1 애플리케이션이 실행 중인 컨테이너 삭제
docker container rm -f todo-v1

# 그다음에는 같은 볼륨을 사용하도록 v2 애플리케이션 컨테이너 실행
docker container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2

# -v플래그는 컨테이너의 파일 시스템 경로에 지정한 볼륨을 마운트하라는 의미이다.
```

## 파일 시스템 마운트를 사용하는 컨테이너 실행하기

볼륨은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있는 점이다. 하지만 호스트의 스토리지를 컨테이너에 좀 더 직접적으로 연결할 수 있는 수단이 있는데 바로 바인드 마운트다. 바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다. 바인드 마운트도 볼륨과 마찬가지로 컨테이너 입장에서는 평범한 디렉터리에 불과하다. 그러나 도커를 사용하는 입장에서는 컨테이너가 호스트 컴퓨터의 파일에 직접 접근할 수 있고 그 반대도 가능해지므로 좀 더 흥미로운 일을 할 수 있다.  

바운드 마운트를 사용하면 호스트 컴퓨터의 파일 시스템을 명시적으로 지정해 컨테이너 데이터로 쓸 수 있다. 속도 면에서 뛰어난 SSD 디스크, 고사용성 디스크 어레이, 네트워크상에서 사용하는 분산 스토리지까지 호스트 컴퓨터에서 접근 가능한 파일 시스템이라면 무엇이든 컨테이너에서도 사용할 수 있다.

``` Console
$ source="$(pwd)\databases" && target='/data' # 리눅스

$ mkdir ./databases

$ docker container run --mount type=bind, source=$source, target=$target -d -p 8012:80 diamol/ch06-todo-list

```

바운드 마운트는 양방향으로 작동한다. 컨테이너에서 만든 파일을 호스트 컴퓨터에서 수정할 수도 있고, 반대로 호스트에서 만든 파일도 컨테이너에서 수정 할 수 있다. 호스트 컴퓨터에 대한 공격을 방지하기 위해 컨테이너는 대개 최소 권한을 가진 계정으로 실행되는데, 바인드 마운트를 사용하면 호스트 컴퓨터 파일에 접근하기 위해 권한 상승이 필요하다. 그래서 Dockerfile스크립트에서 USER 인스트럭션을 사용해 컨테이너에 관리자 권한을 부여한다.








