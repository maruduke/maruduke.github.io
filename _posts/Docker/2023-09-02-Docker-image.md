---
title: 2. 도커 이미지 만들기
author: maruduke
date: 2023-09-02 14:10:00 +0800
categories: [Docker]
tags: [docker]
---

## 도커 허브에 공유된 이미지 사용하기

도커 이미지를 도커CLI를 통해 명시적으로 원하는 이미지를 내려받는 방법
``` console
docker image pull diamol/ch03-web-ping
```

하나의 이미지는 여러 이미지가 계층적으로 쌓인 형태로 저장된다.



이 이미지는 도커가 가장 먼저 이미지를 찾기 위해 접근하는 저장소인 **도커 허브**에 저장돼 있다. 
이미지를 제공하는 저장소를 **레지스트리** 라고 하는데 도커 허브는 무료로 제공되는 공개 레지스트리다.
  
이미지를 내려받는 과정을 보면 여러 건의 파일을 동시에 내려받는다는 점에서 단일 파일을 내려 받는 과정이 아님을 알 수 있다. 이들 각각의 파일을 **이미지 레이어**라고 부른다. 도커 이미지는 물리적으로 여러 개의 작은 파일로 구성되었고 도커가 이들 파일을 조립하여 컨테이너 내부 파일 시스템을 만든다.

    
**환경 변수** 는 운영체제에서 제공하는 키-값 쌍이다. 윈도나 라눅스나 같은 방식으로 동작하며, 아주 적은 양의 데이터를 저장하는데 유용하다. 그러나, 이 환경 변수는 호스트 운영체제의 것을 가져오는게 아니라 컨테이너의 호스트 명이나 IP주소처럼 도커가 부여해준다.
다만 컨테이너를 생성할 때 기본값과 다른 값을 환경 변수로 설정할 수도 있다.

``` console
docker container run --env TARGET=google.com diamol/ch03-web-ping
```


## Dockerfile 작성하기


Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트다. Dockerfile은 일련의 인스트럭션으로 구성돼 있으며, 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다.

``` Dockerfile
FROM diamol/node

ENV TARGET = "blog.sixeyed.com"
ENV METHOD = "HEAD"
ENV INTERVAL = "3000"

WORKDIR /web-ping
COPY app.js .

CMD["node", "/web-ping/app.js"]
```

- FROM: 모든 이미지는 다른 이미지로부터 출발한다. 이 이미지는 diamol/node 이미지를 시작점으로 지정했다. diamol/node이미지에는 web-ping 애플리케이션을 실행하는 데 필요한 런타임인 Node.js가 설치되어 있다.
- ENV: 환경 변수 값을 지정하기 위한 인스트럭션이다. 값을 지정하기 위해 [key] = "[value]" 형식을 따른다.
- WORKDIR: 컨테이너 이미지 파일 시스템에 티렉터리를 만들고, 해당 티렉터리를 작업 디렉터리로 지정하는 인스트럭션이다. 리눅스와 윈도 컨테이너 모두 구분자로 /를 사용
- copy: 로컬 파일 시스템의 파일 혹은 디렉터리를 컨테이너 이미지로 복사하는 인스트럭션이다. [원본경로] [복사경로] 형식으로 지정하면 된다. 위 스크립트는 로컬 파일 시스템에 있는 app.js 파일을 이미지의 작업 디렉터리로 복사했다.
- CMD: 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령을 지정하는 인스트럭션이다. 여기서는 Node.js런타임이 애플리케이션을 시작하도록 app.js를 지정했다.


## 컨테이너 이미지 빌드하기

이미지를 빌드하려면 Dockerfile 스크립트 외에도 필요한 것이 몇 가지 더 있다. 이미지 이름, 패키징에 필요한 파일의 경로를 추가로 지정해 주어야 한다.

``` console
docker image build --tag web-ping .
```
--tag의 인자값은 이미지 이름이고, 이어지는 인자는 Dockerfile 및 이미지에 포함시킬 파일이 위치한 경로다. 도커에서는 이 디렉터리를 컨텍스트라고 한다. 마지막의 .은 '현재 작업 디렉터리'라는 뜻이다.
  




## 도커 이미지와 이미지 레이어 이해하기

도커 이미지에는 우리가 패키징에 포함시킨 모든 파일이 들어 있다. 이들 파일은 나중에 컨테이너의 파일 시스템을 형성한다. 이 외에도 이미지에는 자신에 대한 여러 메타 데이터 정보도 들어 있다. 이 정보 중에는 이미지가 어떻게 빌드됐는지에 대한 간단한 이력도 포함된다. 이 정보를 이용하면 이미지를 구성하는 각 레이어는 무엇이고 이들 레이어가 어떤 명령으로 빌드됐는지 알 수 있다.

``` console
docker image history web-ping
```
이 명령어를 입력하면 한 줄마다 한 레이어에 대한 정보가 출력된다.



## 이미지 레이어 캐시를 이요한 Dockerfile 스크립트 최적화

우리가 조금 전에 빌드한 이미지에는 애플리케이션이 구현된 자바스크립트 파일이 들어있다. 이 파일을 수정하고 이미지를 다시 빌드하면, 새로운 이미지 레이어가 생긴다. 도커의 이미지 레이어가 특정한 순서대로만 배치된다고 가정한다. 그래서 이 순서 중간에 있는 레이어가 변경되면 변경된 레이어보다 위에 오는 레이어를 재사용할 수 없다.

``` console
docker image build -t web-ping:v2
```

이미지를 다시 빌드하면 두번째부터 다섯번째 단계까지는 기존 레이어를 재사용했지만, 6단계 7단계는 새로운 레이어가 만들어진다.
Dockerfile 스크립트의 인스트럭션은 각각 하나의 이미지 레이어와 1:1로 연결된다. 그러나 인스트럭션의 결과가 이전 빌드와 동일하면 이전에 캐시된 레이어를 재사용한다. 이런 방법으로 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다.

이러한 연유로 Dockerfile 스크립트의 인스트럭션은 잘 수정하지 않는 인스트럭션이 앞으로 오고 자주 수정되는 인스트럭션이 뒤에 오도록 배치돼야 한다. 이렇게 해야 캐시에 저장된 이미지 레이어를 되도록 많이 재사용할 수 있습니다.

최적화를 진행한 도커 파일은 다음과 같다.
```dockerfile
FROM diamol/node

CMD ["node", "/web-ping/app.js"]

ENV TARGET = "blog.sixeyed.com" \
    METHOD = "HEAD" \
    INTERVAL = "3000"

WORKDIR /web-ping
COPY app.js .
```